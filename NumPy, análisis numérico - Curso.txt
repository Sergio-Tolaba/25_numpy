NumPy, análisis numérico - Curso
01. Conociendo Numpy
01
Presentación
En esta clase, el instructor Álvaro Camacho presenta el curso de NumPy, que se centra en el análisis numérico eficiente con Python. Se destaca la importancia de la biblioteca NumPy como el paquete fundamental para el análisis científico computacional en Python, ya que muchos módulos y bibliotecas en ciencia de datos se basan en ella.

Durante el curso, se explorarán los arrays (arreglos), sus ventajas, los métodos que se pueden aplicar a ellos, operaciones entre arrays, y la generación de números aleatorios, así como la forma de garantizar su reproducibilidad. Además, se utilizará Google Colab para facilitar el acceso a los recursos sin necesidad de instalar software en la computadora. El objetivo es familiarizar a los estudiantes con NumPy y su utilidad en el trabajo de ciencia de datos. ¡Listos para comenzar!
*************************************************
02
Conoce a Luri, nuestra IA
02
Preparando el ambiente
 Siguiente pregunta

En este curso utilizaremos Google Colab para escribir código en Python y llevar a cabo los experimentos. Para comenzar a utilizar esta herramienta, necesitas tener una cuenta en Google y acceder a este enlace, o si lo prefieres, puedes acceder directamente al notebook inicial.

Además, para seguir el desarrollo del proyecto a lo largo del curso y reproducir todo lo que se ha hecho, puedes descargar el archivo con los datos. También hemos proporcionado la URL utilizada en la lección 1 para cargar los datos.
************************************************
02
Preparando el ambiente
 Siguiente pregunta

En este curso utilizaremos Google Colab para escribir código en Python y llevar a cabo los experimentos. Para comenzar a utilizar esta herramienta, necesitas tener una cuenta en Google y acceder a este enlace, o si lo prefieres, puedes acceder directamente al notebook inicial.

Además, para seguir el desarrollo del proyecto a lo largo del curso y reproducir todo lo que se ha hecho, puedes descargar el archivo con los datos. También hemos proporcionado la URL utilizada en la lección 1 para cargar los datos.
***********************************************
03 Desafío propuesto
En esta clase, se introdujo el concepto de NumPy, una biblioteca fundamental para la computación científica en Python. Se explicó que los analistas de datos trabajan con datasets, que son conjuntos de datos, y en este caso, se analizará el precio de las manzanas en cinco ciudades rusas durante más de siete años.

Se destacó que NumPy utiliza una estructura llamada Array, que almacena datos homogéneos y permite un acceso rápido y eficiente a la memoria. Las ventajas de trabajar con Arrays de NumPy incluyen la rapidez en las operaciones matemáticas y un uso de memoria más eficiente en comparación con las listas de Python.

Además, se mencionó que NumPy permite realizar diversas operaciones matemáticas, estadísticas y de álgebra lineal, lo que lo convierte en una herramienta poderosa para el análisis de datos. Finalmente, se anticipó que en las próximas clases se comenzará a trabajar con un conjunto de datos en un notebook de Colab.
/////////////////////////////////////////////////////////////////////////////////////////////////////////
04
Secuencia de valores
 Siguiente pregunta

En Ciencia de Datos, existen varias situaciones en las que necesitamos evaluar datos relacionados con eventos periódicos que ocurren en una fecha fija o predeterminada, ya que estos pueden tener alguna influencia en el fenómeno que queremos analizar. Un ejemplo de un evento que afecta a muchas personas de diversos países es la Copa del Mundo, organizada por la Federación Internacional de Fútbol (FIFA).

Dado el ejemplo de un evento periódico anterior, crea un array utilizando la función np.arange() que liste todos los años en los que ocurrió o se prevé que ocurra la Copa del Mundo, considerando el intervalo cerrado desde el año 2000 hasta el 2102.

Tip: La primera Copa del Mundo ocurrió en el año 2002.

Alternativa correta
import numpy as np

ano_inicial = 2002
ano_final = 2102
np.arange(ano_inicial, ano_final, 4)

Alternativa correta
import numpy as np

ano_inicial = 2002
ano_final = 2102
np.arange(ano_inicial, ano_final + 1, 4)

Este algoritmo muestra todos los años en el intervalo cerrado de 2000 a 2102 en los que ocurre la Copa del Mundo.

Alternativa correta
import numpy as np

ano_inicial = 2000
ano_final = 2102
np.arange(ano_inicial, ano_final, 4)

Alternativa correta
import numpy

ano_inicial = 2002
ano_final = 2102
np.arange(ano_inicial, ano_final + 1, 4)

¡Enhorabuena, has acertado!
 Discutir en el Fo
*************************************************************************************
05 Cargando los datos
Nuevo notebook en google colab y lo renombro como Numpy	(cada celda la represento con un *)
*
import numpy as np
1) A partir de la url que está en GitHub
*
url='https://gist.githubusercontent.com/ahcamachod/41b8a65c5e5b58125401deafb68af460/raw/f84320f69efa1cc3e86e1db054422cfa4869c63e/manzanas.csv'
*
np.loadtxt(url, delimiter=',',usecols=np.arange(1,88,1)) 

2)Descargamos manzanas.cvs a google drive. Conectamos colab al nuestro drive y buscamos la carpeta Colab Notebooks(1)/Numpy y copiamos la ruta y la guardamos en la variable path
*
from google.colab import drive
drive.mount('/content/drive')
*
path='/content/drive/MyDrive/Colab Notebooks (1)/Numpy/manzanas.csv'
*
np.loadtxt(path, delimiter=',',usecols=np.arange(1,88,1)) 

Resumen:
En esta clase, se introdujo el uso de NumPy para el análisis numérico en Python, centrándose en un conjunto de datos sobre el precio de manzanas en cinco ciudades rusas entre 2013 y 2020. Se explicó cómo cargar este conjunto de datos, apples-ts.csv, en un notebook de Google Colab.

Se presentaron dos métodos para cargar el archivo:

Usando un enlace de gist: Se mostró cómo importar NumPy y utilizar el método loadtxt, especificando el delimitador (coma) y las columnas a utilizar. Se abordó un error común relacionado con espacios vacíos en el archivo y cómo solucionarlo utilizando np.arange para definir el rango de columnas a cargar.

Conectando Google Drive: Se explicó cómo montar Google Drive en Google Colab, copiar la ruta del archivo y cargarlo de manera similar al primer método.

Se destacó la importancia de almacenar los datos en una variable para su análisis posterior. La clase concluyó con la expectativa de comenzar a trabajar con los datos en la próxima sesión.
********************************************************
 06 Para saber más: ventajas de los arrays
 Siguiente pregunta

Las listas en Python son estructuras de datos básicas que pueden contener elementos de diferentes tipos (enteros, cadenas, otras listas, etc.). Por otro lado, Numpy (Numerical Python) es una biblioteca de Python que proporciona soporte para matrices multidimensionales, estructuras de datos más avanzadas y eficientes para cálculos numéricos.

Aquí tienes un ejemplo de cómo convertir una lista en un array Numpy:

import numpy as np

# crea una lista
lista = [1, 2, 3, 4, 5]

# convierte la lista en un array Numpy
array = np.array(lista)

print("Lista: ", lista)
print("Array: ", array)
Copia el código
Salida:

Lista: [1, 2, 3, 4, 5]

Array: [1 2 3 4 5]
Copia el código
Existen varias ventajas en el uso de arrays Numpy en lugar de listas regulares de Python y aquí tienes algunas de ellas:

1. Eficiencia de procesamiento: Las operaciones matemáticas en los arrays Numpy son mucho más rápidas que en las listas regulares, ya que Numpy está optimizado para trabajar con conjuntos de datos homogéneos y libera memoria de la computadora de manera rápida.

2. Facilidad de uso: Las operaciones matemáticas en los arrays Numpy se expresan de manera mucho más clara y concisa que en las listas regulares, lo que hace que el código sea más fácil de leer y mantener.

3. Integración con otras bibliotecas: Numpy es una de las bibliotecas más utilizadas en ciencia de datos y aprendizaje automático. Muchas otras bibliotecas, como Pandas y Matplotlib, están diseñadas para trabajar directamente con arrays Numpy.

Comparación de rendimiento: listas vs arrays

Centrándonos en la eficiencia, podemos comparar el tiempo necesario para realizar un cálculo utilizando listas y arrays.

import numpy as np
import time

# crea una lista con 1000000 elementos
lista = list(range(1000000))

# convierte la lista en un array Numpy
array = np.array(lista)

# comienza a medir el tiempo para la operación con la lista
start_time = time.time()

# realiza la operación de elevar al cuadrado cada elemento de la lista
lista_cuadrado = [i**2 for i in lista]

# detiene el cronómetro
tiempo_lista = time.time() - start_time

# comienza a medir el tiempo para la operación con el array
start_time = time.time()

# realiza la operación de elevar al cuadrado cada elemento del array
array_cuadrado = array**2

# detiene el cronómetro
tiempo_array = time.time() - start_time

print("Tiempo de la operación con la lista: ", tiempo_lista)
print("Tiempo de la operación con el array: ", tiempo_array)
Copia el código
Salida:

Tiempo de la operación con la lista: 0.2745847702026367

Tiempo de la operación con el array: 0.004081010818481445
Copia el código
Como se puede ver, la operación realizada con el array Numpy fue mucho más rápida que con la lista regular, lo que demuestra la eficiencia en el procesamiento con el array.

 Discutir en el Foro
************************************************************************************
07 Dimensiones de los arrays
*
datos.ndim #2 porquee tengo dos dimensiones: meses (x) vs los precios (y)#2
*
datos.shape # forma del tipo 6 filas y 87 columnas #(6, 87)
*
datos_transpuestos = datos.T
datos_transpuestos # array([[ 1.2003,  79.72, 42.67, 62.55, 48.26, 71.25],

En esta clase, se introdujo el uso de la biblioteca NumPy en Python, comenzando con la preparación del entorno en un cuaderno de Colab. Se explicó qué es NumPy y se proporcionó un enlace a su documentación para que los estudiantes puedan explorarla.

Se cargó un conjunto de datos llamado manzanas.csv desde Google Drive y se almacenó en una variable llamada Datos. Se mostró cómo determinar la cantidad de dimensiones del array utilizando el método nDim, que en este caso resultó ser 2, y cómo obtener la forma del array con Datos.shape, que mostró que había 6 filas y 87 columnas.

Además, se discutió la dificultad de visualizar los datos en su forma original y se presentó el método Transpose para facilitar la visualización, convirtiendo filas en columnas y viceversa. Finalmente, se almacenó la información transpuesta en una nueva variable llamada datos_transpuestos, preparándose para experimentar más con NumPy en la próxima clase.
///////////////////////////////////////////////////////////////////
08 Obteniendo las dimensiones
 Siguiente pregunta

Un colega te pidió que cargues una base de datos y verifiques el número de filas y columnas del archivo cargado. Tenía dudas sobre si se habían cargado todas las filas.

¿Cómo determinar las dimensiones correctas de una matriz?

Para responder a esta pregunta, necesitarás acceder al siguiente dataset. Puedes usar la opción skiprows=1 para omitir la primera línea del archivo.

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=1, dtype=float)
np.shape(dato)

NumPy también tiene la función shape() y podemos aplicarla a una matriz para obtener sus dimensiones.

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=1, dtype=float)
dato.shape

El atributo shape se puede consultar a una matriz para obtener sus dimensiones.

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=1, dtype=float)
dato.ndim

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=[1,2], dtype=float)
np.shape(dato)

¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente preg
**********************************************************************************+
09 Haga lo que hicimos
 Siguiente pregunta

Ha llegado el momento de poner a prueba los conocimientos adquiridos durante la lección. Para ello, vamos a utilizar otro conjunto de datos en un desafío que se desarrollará a lo largo del curso. Este conjunto de datos es una versión modificada del archivo disponible en el sitio de Kaggle. Por lo tanto, utilizaremos el archivo raw disponible en Github.

En esta etapa, debes cargar los datos. Para hacerlo, importa NumPy y utiliza la función loadtxt. Utiliza el enlace de la URL y el parámetro usecols para omitir la primera columna. Puedes usar np.arange para crear la secuencia de números que representan las columnas. Por último, también es necesario incluir el parámetro skiprows=1 para que la primera línea de texto se omita al leer el archivo.

Ver opinión del instructor
Opinión del instructor

Para llevar a cabo esta etapa, puedes seguir los siguientes pasos:

import numpy as np
url = 'https://gist.githubusercontent.com/ahcamachod/9be09de793dc3bf1e6c3d98eb4e5b1ef/raw/21b85572693200040e11284ef6dcfc3457ec8e11/citrus.csv'
datos = np.loadtxt(url, delimiter=',', usecols=np.arange(1, 6, 1), skiprows=1)

******************************************************************************************
10 Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Crear arrays con secuencias numéricas.
Cargar archivos.
Verificar las dimensiones de un array.
Realizar la transposición de un array.
********************************************************************
***************************************************************+
02.Exploración de datos
01
Proyecto del aula anterior
 Siguiente pregunta

¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en GitHub

~ https://github.com/alura-es-cursos/2044-numpy-analisis-numerico-eficiente-con-python/tree/aula-2

*************************************************+ 
link Numpy_prof
~ https://github.com/alura-es-cursos/2044-numpy-analisis-numerico-eficiente-con-python/blob/aula-2/Numpy.ipynb
***************************************************************
02
Visualización y selección  - SLICE NOTATION o notación en porciones
En esta clase, aprendimos sobre la exploración de datos utilizando NumPy y cómo visualizar la información de manera efectiva. Comenzamos extrayendo las fechas de un conjunto de datos transpuestos y almacenándolas en una variable llamada fechas. Luego, obtuvimos los precios de las manzanas en diferentes ciudades de Rusia, almacenándolos en la variable precios.

Utilizamos la notación de segmento (slice notation) para seleccionar las filas y columnas adecuadas de nuestros arrays. A continuación, intentamos graficar los precios en función de las fechas utilizando la biblioteca matplotlib. Sin embargo, nos encontramos con un problema de visualización debido a que las fechas eran interpretadas como números decimales.

Para solucionar esto, creamos una nueva variable de fechas secuenciales utilizando np.arange, lo que nos permitió graficar los precios de manera más coherente. Finalmente, comenzamos a crear variables para almacenar los precios de las manzanas en diferentes ciudades, como Moscú, Kaliningrado, Petersburgo, Krasnodar y Ekaterinburgo, y graficamos los precios de Kaliningrado como un ejemplo.

En la próxima clase, se explorarán comparaciones entre los arrays y otros métodos que se pueden aplicar.
//////////////////////////////////////////////////////////////////////////////////////////////
03
Selección de un intervalo
 Siguiente pregunta

Charlie está trabajando con una base de datos de clientes de una tienda.

clientes = np.array([[1, 'Juan', 30, Calle A', 100, 'electrónicos'],
                     [2, 'Maria', 25, 'Calle B', 200, 'moda'],
                     [3, 'Pedro', 35, 'Calle C', 50, 'deportes']])
Copia el código
Las cuatro primeras columnas representan datos personales de los clientes y no puede usarlas en el análisis. Por lo tanto, pretende construir una nueva matriz llamada intencion_compras para almacenar solo las dos últimas columnas de los datos. ¿Qué comando debe utilizar para obtener el resultado deseado?

Alternativa correta
intencion_compras = clientes[:, 4:5]

Alternativa correta
intencion_compras = clientes[:, 4:6]

Esta selección contendrá todas las columnas. Tendremos las columnas 4 y 5.

Alternativa correta
intencion_compras = clientes[4:, :]

Alternativa correta
intencion_compras = clientes[:, 4:]

Esta selección contendrá todas las columnas a partir de la columna 4.
********************************************************************************
04 Comparación entre arrays
En esta clase, se exploró el análisis de datos utilizando arrays en NumPy, específicamente en el contexto del comportamiento del precio de las manzanas en Moscú durante 87 meses. Se explicó cómo separar estos datos en arrays anuales para facilitar la comparación. Se crearon variables para almacenar los precios de las manzanas de los primeros cuatro años (2013 a 2016) y se graficaron utilizando plt.plot, estableciendo una leyenda para identificar cada año.

Además, se discutió la comparación entre arrays utilizando las funciones array_equal y np.all_close, que permiten determinar si dos arrays son iguales o similares, respectivamente. Se mostró cómo ajustar el valor de tolerancia para evaluar la similitud entre los precios de diferentes años. La clase concluyó mencionando que en la próxima sesión se aprenderán más funcionalidades y métodos de la biblioteca NumPy.
**********************************************************************
05
Para saber más: escalares, vectores y matrices
 Siguiente pregunta

A lo largo de este curso, puedes notar cierta similitud entre los números y los arrays con escalares, vectores y matrices en matemáticas. Por lo tanto, hablaremos un poco sobre estos elementos.

Escalares

Los escalares son números simples utilizados en matemáticas o informática. Son números que usamos en una suma o multiplicación. Por ejemplo, la temperatura de hoy es de 27 °C, o mi peso es de 70 kg.

Vectores

En contraste, un vector es una estructura de datos que representa múltiples cantidades relacionadas. Por ejemplo, una secuencia de pesos de boxeadores en una categoría específica. En este caso, un ejemplo de un vector que representaría los pesos de cuatro boxeadores sería este: $(70.0, 72.0, 71.2, 70.5)$. Otro uso común para los vectores es representar la posición de las coordenadas de un objeto en el espacio. En el ejemplo de la figura a continuación, tenemos el punto A en las coordenadas (4,3). Los arrays de la biblioteca Numpy son adecuados para almacenar información de este tipo.

Figura de un punto en un plano bidimensional

Matrices

Al igual que los vectores, las matrices son estructuras de datos que representan múltiples valores relacionados. Una tabla de datos se puede representar mediante una matriz. Aquí tienes un ejemplo de una matriz con 3 filas y 3 columnas:

Figura de una matriz con tres filas y tres columnas

Pero también podemos tener matrices 3D o con más dimensiones. En el ejemplo a continuación, puedes ver una matriz 3D.

Figura de una matriz con tres dimensiones, representada por tres matrices, dispuestas una detrás de la otra y vistas en un ángulo diagonal. Cada matriz es una matriz 3x3 que, juntas, forman la matriz de tres dimensiones.

Las matrices 3D tienen aplicaciones más avanzadas, como el procesamiento de imágenes, el trabajo con animaciones y la modelización matemática.

Un término que escucharás con frecuencia en este curso es "dimensiones". Este término se utilizará aquí para indicar en cuántos ejes varía una información. Por ejemplo, un vector es una secuencia de valores, por lo tanto, podemos decir que varía en solo una dimensión, es unidimensional. En cambio, una matriz 2D, una tabla de datos, tiene filas y columnas, por lo que decimos que es bidimensional.

El término dimensión también puede referirse al número de filas y columnas presentes en una matriz. Podemos tener una matriz con 5 filas y 3 columnas. Eventualmente, puedes ver el número de filas y columnas de una matriz mostrado en su esquina inferior derecha. Siempre escribimos primero el número de filas y luego el número de columnas. Estos números son importantes porque para operaciones como la suma y la multiplicación, las dimensiones de las matrices deben ser compatibles. Solo podemos sumar matrices con el mismo número de filas y columnas. Para que la multiplicación sea posible, el número de columnas de la primera matriz debe ser igual al número de filas de la segunda.
**********************************************************************************
06
Tratamiento de Nan
En esta clase, aprendimos sobre el tratamiento de valores NaN (Not a Number) en un conjunto de datos utilizando NumPy. El objetivo era calcular el precio promedio de las manzanas en Moscú y Kaliningrado.

Primero, se mostró cómo calcular el promedio de precios en Moscú usando np.mean(), obteniendo un resultado de 98 rublos. Sin embargo, al intentar calcular el promedio en Kaliningrado, se encontró un valor NaN, lo que llevó a la necesidad de investigar por qué ocurría esto.

Se utilizó la función np.isnan() para identificar los valores NaN y se explicó cómo contar cuántos había en el array usando np.sum(). Para tratar el valor NaN, se propuso la interpolación, que consiste en tomar los valores adyacentes y calcular su promedio para reemplazar el NaN.

Finalmente, se realizó la interpolación para el valor faltante en Kaliningrado, reemplazándolo con 49.17, y se verificó que ya no había valores NaN. Se concluyó calculando el nuevo promedio de precios en Kaliningrado, que resultó ser 74.55 rublos.

La clase finalizó mencionando que en la próxima sesión se explorarán comparaciones más detalladas entre los precios en diferentes ciudades.

Copiar texto de Luri al portapapeles
///////////////////////////////////////////////////////////////////////////////////////////////
07
Diferencia en un intervalo
 Siguiente pregunta

Patty es una científica que está analizando una base de datos. Está utilizando la biblioteca NumPy para evaluar las columnas de una matriz de datos de un sensor de calor. Cada columna representa la misma información recopilada por un mismo sensor en momentos diferentes. Para validar si el sensor sigue calibrado, necesita que la diferencia entre los valores en las posiciones de una matriz llamada "base" y una columna de la matriz "medidas" sea menor que 0.01.

¿Cómo puede usar NumPy para realizar esta evaluación en la columna cero de la matriz?

Alternativa correta
np.allclose(base, medidas[:, 0], 0.01)

allclose() devolverá True si la diferencia entre los elementos de la matriz es menor que el valor proporcionado de 0.01.

Alternativa correta
np.array_equal(base, medidas[:, 0], 0.01)

Alternativa correta
np.allclose(base, medidas[:, 0], 0.05)

Alternativa correta
np.abs(base - medida[:, 0]) / 0.01
//////////////////////////////////////////////////////////////////////////////////////////
08
Determinando el número de NaNs
 Siguiente pregunta

Estás trabajando con datos de ventas de tu puesto de jugo de limón. Cargaste los datos con load.txt() y, al visualizar la matriz, notaste que había algunos NaNs dentro de ella. Dado que se trata de un archivo grande, decidiste usar código para verificar el número total de estos valores. ¿Cuál es el código adecuado para obtener el resultado deseado en la matriz jugo_de_limon?

Alternativa correta
sum(jugo_de_limon.isnan())

Alternativa correta
np.sum(np.isnan(jugo_de_limon))

También podemos usar np.sum(). Primero usamos isnan para generar una matriz de Verdaderos y Falsos y luego sumamos todos los valores de la matriz.

Alternativa correta
sum(np.isnan(jugo_de_limon))

Primero usamos isnan para generar una matriz de Verdaderos y Falsos y luego sumamos todos los valores de la matriz.

Alternativa correta
sum(np.isnone(jugo_de_limon))

¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente 
***********************************************************************
09
Haga lo que hicimos
 Siguiente pregunta

Ha llegado el momento de poner a prueba los conocimientos adquiridos durante la lección. Continuando con el proyecto de las naranjas/toronjas, ahora debes seleccionar parte de los datos. Las columnas que evaluaremos son el diámetro y el peso. Crea arrays específicos para almacenar el diámetro y el peso de la naranja y la toronja. El diámetro está en la columna cero y el peso en la columna uno. Los datos de las naranjas van hasta la fila 4999 y los datos de las toronjas comienzan en la fila 5000 del archivo.

Después de seleccionar los datos, importa la biblioteca matplotlib y crea un gráfico para el peso en función del diámetro tanto para las naranjas como para las toronjas.

Ver opinión del instructor
Opinión del instructor

Para llevar a cabo esta etapa, puedes seguir los siguientes pasos:

Selección de datos:

diametro_naranja = dato[:5000, 0]
diametro_toronja = dato[5000:, 0]
peso_naranja = dato[:5000, 1]
peso_toronja = dato[5000:, 1]
Copia el código
Visualización:

import matplotlib.pyplot as plt

plt.plot(diametro_naranja, peso_naranja)
plt.plot(diametro_toronja, peso_toronja)
Copia el código
****************************************************************************
10
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Realizar selecciones dentro de arrays.
Construir gráficos utilizando Matplotlib.
Comparar arrays.
Verificar la existencia de NaNs.
********************************************************************
**********************************************************************
03.Operaciones entre arrays
01 Proyecto del aula anterior
¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en Github
************************************
02
Diferencia entre arrays
¡Claro! En esta clase, aprendimos sobre operaciones entre arrays en NumPy, enfocándonos en cómo analizar y visualizar datos. Utilizamos el ejemplo de los precios de las manzanas en Moscú a lo largo de 87 meses.

Primero, se graficaron los precios y se introdujo la idea de ajustar una línea recta a estos datos, utilizando la ecuación de la recta (Y = A \cdot X + B). Se estimó que el precio de las manzanas aumentaba 1.5 veces por mes, y se creó un nuevo array para representar esta línea recta.

Luego, se comparó la diferencia entre los precios reales y la línea recta, observando que los valores eran en su mayoría negativos. Se ajustó la pendiente a 0.5 para ver si se obtenían mejores resultados, lo que llevó a una mezcla de valores positivos y negativos.

Para calcular la diferencia de manera más precisa, se utilizó la función de potencia de NumPy para elevar al cuadrado las diferencias y luego se sumaron, aplicando la raíz cuadrada para obtener un valor absoluto. Se discutió la importancia de minimizar este valor para un mejor ajuste.

Finalmente, se presentó una forma más elegante de calcular la normalización de la diferencia utilizando el método np.linalg.norm, que permitió obtener el mismo resultado de manera más eficiente.

Esta clase nos mostró cómo trabajar con datos y ajustar modelos de forma manual y también cómo utilizar herramientas de NumPy para simplificar el proceso.
****************************************************
03
Para saber más: copias de arrays
 Siguiente pregunta

Cuando trabajamos con arrays u otras variables en Python, a menudo realizamos copias de las variables con las que estamos tratando. Cuando hacemos una copia de una variable, debemos tener en cuenta lo que sucede con ella para evitar utilizar ciertos valores pensando que son otros valores. Para manejar copias de arrays, la biblioteca Numpy tiene una función específica.

En este ejemplo, tengo un array con el nombre "precio_inmuebles" que quiero copiar.

precio_inmuebles = np.array([10000, 120000, 11000, 200000])
Copia el código
El objetivo es colocar los valores de este array en uno con un nombre específico para los precios de las propiedades en Lima. Vamos a hacer la copia utilizando el signo igual (=).

precio_inmuebles_lima = precio_inmuebles
Copia el código
Si verificas los valores en la nueva variable "precio_inmuebles_lima", verás que son los mismos que los de la variable "precio_inmuebles". Sin embargo, dado que "guardamos" los precios en la variable "precio_inmuebles_lima", ¿qué te parece reemplazar el valor de la primera propiedad en el array "precio_inmuebles" con uno nuevo que acaba de entrar en nuestro registro?

precio_inmuebles[0] = 120000
Copia el código
Si intentas reproducir el proceso realizado hasta ahora, verás que este cambio en el array "precio_inmuebles" también cambió la primera posición del array "precio_inmuebles_lima" al valor de 120000.

Para crear un array independiente del array original, existe una función en Numpy, "np.copy()". Para crear la copia utilizando esta función, simplemente sigue este código:

precio_inmuebles_lima = np.copy(precio_inmuebles)
Copia el código
De esta manera, incluso si modificamos el array "precio_inmuebles", no afectará al array "precio_inmuebles_lima".

Esto sucede porque, cuando usamos el signo igual para copiar el array, tenemos un nuevo array que apunta a las mismas ubicaciones en la memoria. En cambio, cuando usamos "np.copy()", las ubicaciones en la memoria son diferentes.

Imagen con tres tablas de una tabla de dos columnas, ID y VALOR. Desde la primera tabla, hay dos flechas hacia las otras dos tablas: una con el signo igual y la otra con "np.copy()". La figura muestra lo que sucede cuando copiamos un array usando el signo igual y cuando usamos "np.copy()".
****************************************************************
04
Regresión lineal

En esta clase, se abordó el tema de la regresión lineal utilizando la biblioteca NumPy en Python. Se explicó cómo calcular la pendiente (alfa) y la intersección (beta) de una línea que representa un conjunto de datos, en este caso, los precios de los kilos de manzana en Moscú.

Se presentó la fórmula para calcular la pendiente, que involucra el número de observaciones y sumatorias de productos entre las fechas y los precios. También se discutió cómo calcular la intersección utilizando el promedio de los precios y las fechas.

Se enfatizó la importancia de utilizar NumPy para realizar estos cálculos de manera eficiente y elegante, evitando el método de prueba y error. Finalmente, se mostró cómo obtener el valor de Y a partir de la ecuación de la recta y se mencionó la posibilidad de graficar los resultados para visualizar la relación entre los datos.

La clase concluyó con la invitación a seguir explorando las capacidades de NumPy para la computación científica.

//////////////////////////////////////////////////////////////////////////////////////////////
05
Implementando una ecuación
 Siguiente pregunta

Tatiana quería dibujar un círculo con la ayuda de la computadora. Para dibujar la parte superior del círculo, sabía que debía usar la ecuación:

y = sqrt(1 - x ^ 2)
Copia el código
Y para la parte inferior, solo tenía que usar la misma ecuación multiplicada por -1.

¿Cuál secuencia de código debe usar para construir el gráfico correctamente usando NumPy y sabiendo que ambas partes del círculo deben tener el mismo color?

Alternativa correta
import numpy as np
import matplotlib.pyplot as plt

# Generar una secuencia de valores de x de -1 a 1
x = np.arange(-1, 1, 0.0001)

# Implementación de la fórmula
y1 = np.sqrt(1 - x**2)
y2 = -np.sqrt(1 - x**2)

# Graficar el gráfico con las dos partes del círculo
plt.plot(x, y1, 'r')
plt.plot(x, y2, 'r' )

# Agregar el título del gráfico y las etiquetas de los ejes x e y
plt.title("Círculo")
plt.xlabel("Eje x")
plt.ylabel("Eje y")

# Mostrar el gráfico
plt.show()

Ella implementó la ecuación para la parte superior e inferior del círculo y generó un gráfico para ambas partes con el mismo color.

Alternativa correta
import numpy as np
import matplotlib.pyplot as plt

# Generar una secuencia de valores de x de -1 a 1
x = np.arange(-1, 1, 0.0001)

# Implementación de la fórmula
y = np.sqrt(1 - x**2) - np.sqrt(1 - x**2)

# Graficar el gráfico con las dos partes del círculo
plt.plot(x, y, 'r')

# Agregar el título del gráfico y las etiquetas de los ejes x e y
plt.title("Círculo")
plt.xlabel("Eje x")
plt.ylabel("Eje y")

# Mostrar el gráfico
plt.show()

Si intentas ejecutar este código, verás que obtenemos una secuencia de ceros para los valores de y.

Alternativa correta
import numpy as np
import matplotlib.pyplot as plt

# Generar una secuencia de valores de x de -1 a 1
x = np.arange(-1, 1, 0.0001)

# Implementación de la fórmula
y1 = np.power(1 - x, 2)
y2 = -np.power(1 - x, 2)

# Graficar el gráfico con las dos partes del círculo
plt.plot(x, y1, 'r')
plt.plot(x, y2, 'r' )

# Agregar el título del gráfico y las etiquetas de los ejes x e y
plt.title("Círculo")
plt.xlabel("Eje x")
plt.ylabel("Eje y")

# Mostrar el gráfico
plt.show()

Observa que aquí en lugar de sacar la raíz cuadrada, elevó los elementos de la matriz al cuadrado.

¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente p
*******************************************************************************************
 06 Aplicación de la regresión
En esta clase, se abordó el uso de la biblioteca NumPy para realizar análisis numérico, específicamente en la aplicación de la regresión lineal. Se explicó cómo establecer la línea que mejor describe un conjunto de datos utilizando una ecuación de primer grado, que relaciona la variable dependiente (y) con la variable independiente (x) a través de la pendiente y el coeficiente de intersección.

Se mostró cómo calcular el precio de un producto, como las manzanas, en un momento específico, utilizando la ecuación de la línea. Por ejemplo, se calculó el precio en enero de 2015, que corresponde al mes 25, y se estimó que el precio sería de 90.52. También se realizó un cálculo para el mes 75, obteniendo un precio estimado de 112.

Se mencionó que, aunque la regresión lineal es útil, existen otras ecuaciones de grados superiores que podrían ajustarse mejor a los datos, aunque esto puede llevar al problema del sobreajuste (overfitting). Finalmente, se anticipó que en la próxima clase se explorarán recursos de NumPy para trabajar con números aleatorios, lo que permitirá encontrar la mejor línea sin necesidad de experimentar manualmente con los números.
***************************************************************
07
Para saber más: regresión
 Siguiente pregunta

La regresión es ampliamente utilizada en ciencia de datos para la predicción y también para la interpolación de valores. Su uso tiene varios aspectos y hemos seleccionado algunos cursos de Alura Latam que puedes tomar para profundizar en el tema.

Regresión Lineal: Análisis de correlaciones y previsión de resultados
Regresión Lineal: Técnicas Avanzadas de Modelado
Data Analysis: previsiones con Google Sheets
Regresión: Implementa una red neuronal con numpy
Son 4 links a cursos en Alura a los cuales no tengo acceso, hay que pagar
**************************************************************************
08
Haga lo que hicimos
 Siguiente pregunta

Ha llegado el momento de poner a prueba los conocimientos adquiridos durante la lección. Continuando con el proyecto de las naranjas/toronjas, ahora debes calcular el coeficiente angular y lineal para la recta de las naranjas y para la recta de las toronjas. Utiliza la fórmula de mínimos cuadrados para encontrar cada uno.

Ver opinión del instructor
Opinión del instructor

Para llevar a cabo esta etapa, puedes seguir los siguientes pasos:

Coeficientes para las naranjas:

Y = peso_naranja
X = diametro_naranja
n = np.size(X)

a = (n*np.sum(X*Y) - np.sum(X)*np.sum(Y))/(n*np.sum(X**2)-np.sum(X)**2)
b = np.mean(Y) - a*np.mean(X)
Copia el código
Para las toronjas, simplemente reemplaza "naranja" por "toronja" en el nombre de las variables
**********************************************************
09
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Realizar operaciones entre arrays.
Calcular la norma entre dos arrays.
Implementar la regresión lineal.
*****************************************************************
****************************************************************+
04.Números aleatorios
01
Proyecto del aula anterior
¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en Github

~ https://github.com/alura-es-cursos/2044-numpy-analisis-numerico-eficiente-con-python/tree/aula-4
*****************************************************************
02
Generando números aleatorios
En esta clase, aprendimos sobre la generación de números aleatorios utilizando NumPy, lo cual es fundamental en la computación científica para realizar experimentos y pruebas. Se explicó cómo generar números aleatorios enteros con la función np.random.randint y números aleatorios de tipo float con np.random.uniform, especificando un rango inferior y superior, así como la cantidad de números deseados.

Se destacó la importancia de los números aleatorios en la estimación de valores, como las pendientes en un modelo, permitiendo realizar múltiples iteraciones sin necesidad de ingresar manualmente cada valor. Además, se mostró cómo calcular la norma utilizando np.linalg.norm, que ayuda a evaluar la precisión de las predicciones.

Finalmente, se mencionó que al generar números aleatorios, los resultados pueden variar en cada ejecución, a menos que se establezca un estado de aleatoriedad específico. Esto es crucial para entender cómo funcionan los números aleatorios en la práctica.
*****************************************************************
03
Reproductibilidad
En esta clase, se abordó el concepto de números aleatorios en NumPy y la importancia de la reproducibilidad en la generación de estos números. Se explicó que, aunque los números generados parecen aleatorios, en realidad son pseudoaleatorios, ya que dependen de un algoritmo y de una semilla (o random seed).

Se destacó que al establecer una semilla con np.random.seed, se puede garantizar que los números generados sean los mismos en cada ejecución, lo cual es crucial para realizar experimentos y análisis consistentes. Se mostró cómo, al ejecutar el mismo código en la misma celda después de establecer la semilla, los resultados permanecen constantes.

Finalmente, se mencionó que, aunque ya sabemos cómo crear Arrays, en la próxima clase se explorará cómo unir varios Arrays para crear estructuras similares a tablas, lo que facilitará la exportación y el uso en futuros experimentos.
///////////////////////////////////////////////////////////////////////////////////
04
Los mismos valores
 Siguiente pregunta

Micaela quería generar dos secuencias de números aleatorios diferentes entre 0 y 5 en su código. Supongamos que ella escribió lo siguiente:

import numpy as np

np.random.seed(42)
a = np.random.uniform(0, 1, 5)
np.random.seed(42)
b = np.random.uniform(0, 1, 5)
Copia el código
¿Qué problemas está experimentando con este código?

Alternativa correta
La secuencia de código generará 5 números entre 0 y 1. A pesar de ello, seed(42) hará que las dos secuencias sean diferentes y reproducibles.


Alternativa correta
La secuencia de código generará solo un número entre cero y 5. Además, seed(42) hará que ambas secuencias sean iguales.


Alternativa correta
La secuencia de código generará 5 números entre 0 y 1. Además, seed(42) hará que ambas secuencias sean iguales.


La elección del primer valor dentro de random.uniform es el primer valor posible en la secuencia, el segundo valor es el último valor posible y el último valor es el número de valores en la secuencia. Además, colocar random.seed con el mismo número justo antes de la llamada a la función hará que se genere la misma secuencia. Un ejemplo de código que resolvería el problema correctamente es este, observe que se generarán secuencias de 5 números:

import numpy as np

np.random.seed(42)
a = np.random.uniform(0, 5, 5)
np.random.seed(8)
b = np.random.uniform(0, 5, 5)
Copia el código
¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente pregunta
****************************************************************************
05
Exportación
En esta clase, aprendimos sobre la exportación de datos utilizando la biblioteca NumPy en Python. Comenzamos generando números aleatorios y trabajando con NumPy Arrays, específicamente con dos arreglos llamados pendientes y normas.

Vimos cómo combinar estos arreglos en una nueva variable llamada datos utilizando la función column_stack, que nos permite apilar columnas. Al verificar la forma de datos, observamos que tiene 100 filas y 2 columnas.

Luego, aprendimos a almacenar estos datos en un archivo CSV en nuestra cuenta de Drive. Utilizamos la función np.save.txt para guardar los datos, especificando la ruta del archivo y el delimitador (en este caso, comas). Finalmente, revisamos cómo acceder y visualizar el archivo guardado en Drive.

La clase subrayó la importancia de experimentar con NumPy y explorar sus diversas funcionalidades para fortalecer nuestras habilidades en ciencia de datos.
///////////////////////////////////////////////////////////////
06
Aplicando a Numpy
 Siguiente pregunta

Has comenzado tus estudios con la biblioteca Numpy y decidiste usarla para reemplazar un cálculo que se realizaba con listas de Python. La lista que tienes en tus manos es la siguiente:

x = [0,1,2,3,4,5,6,7,8,9,10]
Copia el código
Esta lista se estaba utilizando para calcular varios valores de "y" en la ecuación y = x + 3 / 2. ¿Cómo se vería el código en Numpy para reemplazar el siguiente fragmento de código?

x = [0,1,2,3,4,5,6,7,8,9,10]
y = []

for i in x:
  y.append(i + 3 / 2)
Copia el código
Tip: Ejecuta el código anterior antes y verifique los valores en las variables x e y con la función print() para comparar los resultados del array.

Alternativa correta
import numpy as np
x = [0,1,2,3,4,5,6,7,8,9,10]
x = np.array(x)

for i in x:
  y = i + 3 / 2

Este código calcula el valor de la ecuación Y para cada valor de X, pero solo se almacena el último valor, ya que el bucle for sobrescribe la variable y. Con Numpy, podemos crear el array con todos los valores, además de resumir el código y hacerlo más limpio.

Alternativa correta
import numpy
x = [0,1,2,3,4,5,6,7,8,9,10]
x = array(x)
y = x + 3 / 2

Alternativa correta
import numpy as np
x = [0,1,2,3,4,5,6,7,8,9,10]
x = np.array(x)
y = x + 3 / 2

Primero debemos importar la biblioteca y convertir la lista en un array. Luego podemos realizar el cálculo de manera normal. Esto nos dará un array con valores equivalentes al resultado con la lista de Python.
**********************************************************************
07
Haga lo que hicimos
 Siguiente pregunta

Ha llegado el momento de poner a prueba los conocimientos adquiridos durante la lección. Continuando con el proyecto de las naranjas/toronjas, ahora debes calcular el coeficiente angular utilizando la generación de números aleatorios. Supongamos que ya conoces el valor de b y que este es igual a 17.

Ver opinión del instructor
Opinión del instructor

Para llevar a cabo esta etapa, puedes seguir los siguientes pasos:

norma = np.array([])
np.random.seed(84)
coeficientes_angulares = np.random.uniform(low=0.0, high=30.0, size=100)

for i in range(100):
  norma = np.append(norma, np.linalg.norm(Y - (coeficientes_angulares[i]*X + b)))
Copia el código
En este código, se genera una serie de coeficientes angulares aleatorios y se calcula la norma de la diferencia entre Y y el valor calculado para cada coeficiente angular. Estos valores se almacenan en el array norma.

 Discutir en el Foro
*********************************************************************************+
08
Proyecto Final
 Siguiente pregunta

Aquí puedes descargar los archivos del proyecto completo.

Descargue los archivos en GitHub
****************************************************************
09
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Generar secuencias de números aleatorios.
Garantizar la reproducibilidad de resultados.
Agrupar arrays.
Guardar archivos.
**************************************************
10
Conclusión
En esta clase sobre NumPy, hemos explorado la importancia de esta biblioteca para la computación científica en Python. Aprendimos qué es un array (matriz) y las ventajas de trabajar con ellos, así como las diversas operaciones matemáticas que se pueden realizar. Se presentó un caso práctico donde trazamos una línea recta para prever el comportamiento del precio de las manzanas en ciudades rusas.

Además, discutimos la utilidad de generar números aleatorios y la posibilidad de reproducirlos para experimentos futuros, así como la exportación de archivos con los datos resultantes. Finalmente, se enfatizó la importancia de seguir practicando y explorando más funciones de NumPy, así como su integración con otras bibliotecas como Matplotlib, Pandas y SciPy. ¡Espero que hayas disfrutado del entrenamiento y sigas experimentando!
****************************************************************
