NumPy, análisis numérico - Curso
01. Conociendo Numpy
01
Presentación
En esta clase, el instructor Álvaro Camacho presenta el curso de NumPy, que se centra en el análisis numérico eficiente con Python. Se destaca la importancia de la biblioteca NumPy como el paquete fundamental para el análisis científico computacional en Python, ya que muchos módulos y bibliotecas en ciencia de datos se basan en ella.

Durante el curso, se explorarán los arrays (arreglos), sus ventajas, los métodos que se pueden aplicar a ellos, operaciones entre arrays, y la generación de números aleatorios, así como la forma de garantizar su reproducibilidad. Además, se utilizará Google Colab para facilitar el acceso a los recursos sin necesidad de instalar software en la computadora. El objetivo es familiarizar a los estudiantes con NumPy y su utilidad en el trabajo de ciencia de datos. ¡Listos para comenzar!
*************************************************
02
Conoce a Luri, nuestra IA
02
Preparando el ambiente
 Siguiente pregunta

En este curso utilizaremos Google Colab para escribir código en Python y llevar a cabo los experimentos. Para comenzar a utilizar esta herramienta, necesitas tener una cuenta en Google y acceder a este enlace, o si lo prefieres, puedes acceder directamente al notebook inicial.

Además, para seguir el desarrollo del proyecto a lo largo del curso y reproducir todo lo que se ha hecho, puedes descargar el archivo con los datos. También hemos proporcionado la URL utilizada en la lección 1 para cargar los datos.
************************************************
02
Preparando el ambiente
 Siguiente pregunta

En este curso utilizaremos Google Colab para escribir código en Python y llevar a cabo los experimentos. Para comenzar a utilizar esta herramienta, necesitas tener una cuenta en Google y acceder a este enlace, o si lo prefieres, puedes acceder directamente al notebook inicial.

Además, para seguir el desarrollo del proyecto a lo largo del curso y reproducir todo lo que se ha hecho, puedes descargar el archivo con los datos. También hemos proporcionado la URL utilizada en la lección 1 para cargar los datos.
***********************************************
03 Desafío propuesto
En esta clase, se introdujo el concepto de NumPy, una biblioteca fundamental para la computación científica en Python. Se explicó que los analistas de datos trabajan con datasets, que son conjuntos de datos, y en este caso, se analizará el precio de las manzanas en cinco ciudades rusas durante más de siete años.

Se destacó que NumPy utiliza una estructura llamada Array, que almacena datos homogéneos y permite un acceso rápido y eficiente a la memoria. Las ventajas de trabajar con Arrays de NumPy incluyen la rapidez en las operaciones matemáticas y un uso de memoria más eficiente en comparación con las listas de Python.

Además, se mencionó que NumPy permite realizar diversas operaciones matemáticas, estadísticas y de álgebra lineal, lo que lo convierte en una herramienta poderosa para el análisis de datos. Finalmente, se anticipó que en las próximas clases se comenzará a trabajar con un conjunto de datos en un notebook de Colab.
/////////////////////////////////////////////////////////////////////////////////////////////////////////
04
Secuencia de valores
 Siguiente pregunta

En Ciencia de Datos, existen varias situaciones en las que necesitamos evaluar datos relacionados con eventos periódicos que ocurren en una fecha fija o predeterminada, ya que estos pueden tener alguna influencia en el fenómeno que queremos analizar. Un ejemplo de un evento que afecta a muchas personas de diversos países es la Copa del Mundo, organizada por la Federación Internacional de Fútbol (FIFA).

Dado el ejemplo de un evento periódico anterior, crea un array utilizando la función np.arange() que liste todos los años en los que ocurrió o se prevé que ocurra la Copa del Mundo, considerando el intervalo cerrado desde el año 2000 hasta el 2102.

Tip: La primera Copa del Mundo ocurrió en el año 2002.

Alternativa correta
import numpy as np

ano_inicial = 2002
ano_final = 2102
np.arange(ano_inicial, ano_final, 4)

Alternativa correta
import numpy as np

ano_inicial = 2002
ano_final = 2102
np.arange(ano_inicial, ano_final + 1, 4)

Este algoritmo muestra todos los años en el intervalo cerrado de 2000 a 2102 en los que ocurre la Copa del Mundo.

Alternativa correta
import numpy as np

ano_inicial = 2000
ano_final = 2102
np.arange(ano_inicial, ano_final, 4)

Alternativa correta
import numpy

ano_inicial = 2002
ano_final = 2102
np.arange(ano_inicial, ano_final + 1, 4)

¡Enhorabuena, has acertado!
 Discutir en el Fo
*************************************************************************************
05 Cargando los datos
Nuevo notebook en google colab y lo renombro como Numpy	(cada celda la represento con un *)
*
import numpy as np
1) A partir de la url que está en GitHub
*
url='https://gist.githubusercontent.com/ahcamachod/41b8a65c5e5b58125401deafb68af460/raw/f84320f69efa1cc3e86e1db054422cfa4869c63e/manzanas.csv'
*
np.loadtxt(url, delimiter=',',usecols=np.arange(1,88,1)) 

2)Descargamos manzanas.cvs a google drive. Conectamos colab al nuestro drive y buscamos la carpeta Colab Notebooks(1)/Numpy y copiamos la ruta y la guardamos en la variable path
*
from google.colab import drive
drive.mount('/content/drive')
*
path='/content/drive/MyDrive/Colab Notebooks (1)/Numpy/manzanas.csv'
*
np.loadtxt(path, delimiter=',',usecols=np.arange(1,88,1)) 

Resumen:
En esta clase, se introdujo el uso de NumPy para el análisis numérico en Python, centrándose en un conjunto de datos sobre el precio de manzanas en cinco ciudades rusas entre 2013 y 2020. Se explicó cómo cargar este conjunto de datos, apples-ts.csv, en un notebook de Google Colab.

Se presentaron dos métodos para cargar el archivo:

Usando un enlace de gist: Se mostró cómo importar NumPy y utilizar el método loadtxt, especificando el delimitador (coma) y las columnas a utilizar. Se abordó un error común relacionado con espacios vacíos en el archivo y cómo solucionarlo utilizando np.arange para definir el rango de columnas a cargar.

Conectando Google Drive: Se explicó cómo montar Google Drive en Google Colab, copiar la ruta del archivo y cargarlo de manera similar al primer método.

Se destacó la importancia de almacenar los datos en una variable para su análisis posterior. La clase concluyó con la expectativa de comenzar a trabajar con los datos en la próxima sesión.
********************************************************
 06 Para saber más: ventajas de los arrays
 Siguiente pregunta

Las listas en Python son estructuras de datos básicas que pueden contener elementos de diferentes tipos (enteros, cadenas, otras listas, etc.). Por otro lado, Numpy (Numerical Python) es una biblioteca de Python que proporciona soporte para matrices multidimensionales, estructuras de datos más avanzadas y eficientes para cálculos numéricos.

Aquí tienes un ejemplo de cómo convertir una lista en un array Numpy:

import numpy as np

# crea una lista
lista = [1, 2, 3, 4, 5]

# convierte la lista en un array Numpy
array = np.array(lista)

print("Lista: ", lista)
print("Array: ", array)
Copia el código
Salida:

Lista: [1, 2, 3, 4, 5]

Array: [1 2 3 4 5]
Copia el código
Existen varias ventajas en el uso de arrays Numpy en lugar de listas regulares de Python y aquí tienes algunas de ellas:

1. Eficiencia de procesamiento: Las operaciones matemáticas en los arrays Numpy son mucho más rápidas que en las listas regulares, ya que Numpy está optimizado para trabajar con conjuntos de datos homogéneos y libera memoria de la computadora de manera rápida.

2. Facilidad de uso: Las operaciones matemáticas en los arrays Numpy se expresan de manera mucho más clara y concisa que en las listas regulares, lo que hace que el código sea más fácil de leer y mantener.

3. Integración con otras bibliotecas: Numpy es una de las bibliotecas más utilizadas en ciencia de datos y aprendizaje automático. Muchas otras bibliotecas, como Pandas y Matplotlib, están diseñadas para trabajar directamente con arrays Numpy.

Comparación de rendimiento: listas vs arrays

Centrándonos en la eficiencia, podemos comparar el tiempo necesario para realizar un cálculo utilizando listas y arrays.

import numpy as np
import time

# crea una lista con 1000000 elementos
lista = list(range(1000000))

# convierte la lista en un array Numpy
array = np.array(lista)

# comienza a medir el tiempo para la operación con la lista
start_time = time.time()

# realiza la operación de elevar al cuadrado cada elemento de la lista
lista_cuadrado = [i**2 for i in lista]

# detiene el cronómetro
tiempo_lista = time.time() - start_time

# comienza a medir el tiempo para la operación con el array
start_time = time.time()

# realiza la operación de elevar al cuadrado cada elemento del array
array_cuadrado = array**2

# detiene el cronómetro
tiempo_array = time.time() - start_time

print("Tiempo de la operación con la lista: ", tiempo_lista)
print("Tiempo de la operación con el array: ", tiempo_array)
Copia el código
Salida:

Tiempo de la operación con la lista: 0.2745847702026367

Tiempo de la operación con el array: 0.004081010818481445
Copia el código
Como se puede ver, la operación realizada con el array Numpy fue mucho más rápida que con la lista regular, lo que demuestra la eficiencia en el procesamiento con el array.

 Discutir en el Foro
************************************************************************************
07 Dimensiones de los arrays
*
datos.ndim #2 porquee tengo dos dimensiones: meses (x) vs los precios (y)#2
*
datos.shape # forma del tipo 6 filas y 87 columnas #(6, 87)
*
datos_transpuestos = datos.T
datos_transpuestos # array([[ 1.2003,  79.72, 42.67, 62.55, 48.26, 71.25],

En esta clase, se introdujo el uso de la biblioteca NumPy en Python, comenzando con la preparación del entorno en un cuaderno de Colab. Se explicó qué es NumPy y se proporcionó un enlace a su documentación para que los estudiantes puedan explorarla.

Se cargó un conjunto de datos llamado manzanas.csv desde Google Drive y se almacenó en una variable llamada Datos. Se mostró cómo determinar la cantidad de dimensiones del array utilizando el método nDim, que en este caso resultó ser 2, y cómo obtener la forma del array con Datos.shape, que mostró que había 6 filas y 87 columnas.

Además, se discutió la dificultad de visualizar los datos en su forma original y se presentó el método Transpose para facilitar la visualización, convirtiendo filas en columnas y viceversa. Finalmente, se almacenó la información transpuesta en una nueva variable llamada datos_transpuestos, preparándose para experimentar más con NumPy en la próxima clase.
///////////////////////////////////////////////////////////////////
08 Obteniendo las dimensiones
 Siguiente pregunta

Un colega te pidió que cargues una base de datos y verifiques el número de filas y columnas del archivo cargado. Tenía dudas sobre si se habían cargado todas las filas.

¿Cómo determinar las dimensiones correctas de una matriz?

Para responder a esta pregunta, necesitarás acceder al siguiente dataset. Puedes usar la opción skiprows=1 para omitir la primera línea del archivo.

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=1, dtype=float)
np.shape(dato)

NumPy también tiene la función shape() y podemos aplicarla a una matriz para obtener sus dimensiones.

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=1, dtype=float)
dato.shape

El atributo shape se puede consultar a una matriz para obtener sus dimensiones.

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=1, dtype=float)
dato.ndim

Alternativa correta
url = 'https://raw.githubusercontent.com/allanspadini/numpy/dados/bytebank.csv'
import numpy as np
dato = np.loadtxt(url, delimiter=',', skiprows=[1,2], dtype=float)
np.shape(dato)

¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente preg
**********************************************************************************+
09 Haga lo que hicimos
 Siguiente pregunta

Ha llegado el momento de poner a prueba los conocimientos adquiridos durante la lección. Para ello, vamos a utilizar otro conjunto de datos en un desafío que se desarrollará a lo largo del curso. Este conjunto de datos es una versión modificada del archivo disponible en el sitio de Kaggle. Por lo tanto, utilizaremos el archivo raw disponible en Github.

En esta etapa, debes cargar los datos. Para hacerlo, importa NumPy y utiliza la función loadtxt. Utiliza el enlace de la URL y el parámetro usecols para omitir la primera columna. Puedes usar np.arange para crear la secuencia de números que representan las columnas. Por último, también es necesario incluir el parámetro skiprows=1 para que la primera línea de texto se omita al leer el archivo.

Ver opinión del instructor
Opinión del instructor

Para llevar a cabo esta etapa, puedes seguir los siguientes pasos:

import numpy as np
url = 'https://gist.githubusercontent.com/ahcamachod/9be09de793dc3bf1e6c3d98eb4e5b1ef/raw/21b85572693200040e11284ef6dcfc3457ec8e11/citrus.csv'
datos = np.loadtxt(url, delimiter=',', usecols=np.arange(1, 6, 1), skiprows=1)

******************************************************************************************
10 Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Crear arrays con secuencias numéricas.
Cargar archivos.
Verificar las dimensiones de un array.
Realizar la transposición de un array.
********************************************************************
***************************************************************+
02.Exploración de datos
01
Proyecto del aula anterior
 Siguiente pregunta

¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en GitHub

~ https://github.com/alura-es-cursos/2044-numpy-analisis-numerico-eficiente-con-python/tree/aula-2

*************************************************+ 
link Numpy_prof
~ https://github.com/alura-es-cursos/2044-numpy-analisis-numerico-eficiente-con-python/blob/aula-2/Numpy.ipynb
***************************************************************
02
Visualización y selección  - SLICE NOTATION o notación en porciones
En esta clase, aprendimos sobre la exploración de datos utilizando NumPy y cómo visualizar la información de manera efectiva. Comenzamos extrayendo las fechas de un conjunto de datos transpuestos y almacenándolas en una variable llamada fechas. Luego, obtuvimos los precios de las manzanas en diferentes ciudades de Rusia, almacenándolos en la variable precios.

Utilizamos la notación de segmento (slice notation) para seleccionar las filas y columnas adecuadas de nuestros arrays. A continuación, intentamos graficar los precios en función de las fechas utilizando la biblioteca matplotlib. Sin embargo, nos encontramos con un problema de visualización debido a que las fechas eran interpretadas como números decimales.

Para solucionar esto, creamos una nueva variable de fechas secuenciales utilizando np.arange, lo que nos permitió graficar los precios de manera más coherente. Finalmente, comenzamos a crear variables para almacenar los precios de las manzanas en diferentes ciudades, como Moscú, Kaliningrado, Petersburgo, Krasnodar y Ekaterinburgo, y graficamos los precios de Kaliningrado como un ejemplo.

En la próxima clase, se explorarán comparaciones entre los arrays y otros métodos que se pueden aplicar.
//////////////////////////////////////////////////////////////////////////////////////////////
03
Selección de un intervalo
 Siguiente pregunta

Charlie está trabajando con una base de datos de clientes de una tienda.

clientes = np.array([[1, 'Juan', 30, Calle A', 100, 'electrónicos'],
                     [2, 'Maria', 25, 'Calle B', 200, 'moda'],
                     [3, 'Pedro', 35, 'Calle C', 50, 'deportes']])
Copia el código
Las cuatro primeras columnas representan datos personales de los clientes y no puede usarlas en el análisis. Por lo tanto, pretende construir una nueva matriz llamada intencion_compras para almacenar solo las dos últimas columnas de los datos. ¿Qué comando debe utilizar para obtener el resultado deseado?

Alternativa correta
intencion_compras = clientes[:, 4:5]

Alternativa correta
intencion_compras = clientes[:, 4:6]

Esta selección contendrá todas las columnas. Tendremos las columnas 4 y 5.

Alternativa correta
intencion_compras = clientes[4:, :]

Alternativa correta
intencion_compras = clientes[:, 4:]

Esta selección contendrá todas las columnas a partir de la columna 4.
********************************************************************************
04 Comparación entre arrays
En esta clase, se exploró el análisis de datos utilizando arrays en NumPy, específicamente en el contexto del comportamiento del precio de las manzanas en Moscú durante 87 meses. Se explicó cómo separar estos datos en arrays anuales para facilitar la comparación. Se crearon variables para almacenar los precios de las manzanas de los primeros cuatro años (2013 a 2016) y se graficaron utilizando plt.plot, estableciendo una leyenda para identificar cada año.

Además, se discutió la comparación entre arrays utilizando las funciones array_equal y np.all_close, que permiten determinar si dos arrays son iguales o similares, respectivamente. Se mostró cómo ajustar el valor de tolerancia para evaluar la similitud entre los precios de diferentes años. La clase concluyó mencionando que en la próxima sesión se aprenderán más funcionalidades y métodos de la biblioteca NumPy.
**********************************************************************
05
Para saber más: escalares, vectores y matrices
 Siguiente pregunta

A lo largo de este curso, puedes notar cierta similitud entre los números y los arrays con escalares, vectores y matrices en matemáticas. Por lo tanto, hablaremos un poco sobre estos elementos.

Escalares

Los escalares son números simples utilizados en matemáticas o informática. Son números que usamos en una suma o multiplicación. Por ejemplo, la temperatura de hoy es de 27 °C, o mi peso es de 70 kg.

Vectores

En contraste, un vector es una estructura de datos que representa múltiples cantidades relacionadas. Por ejemplo, una secuencia de pesos de boxeadores en una categoría específica. En este caso, un ejemplo de un vector que representaría los pesos de cuatro boxeadores sería este: $(70.0, 72.0, 71.2, 70.5)$. Otro uso común para los vectores es representar la posición de las coordenadas de un objeto en el espacio. En el ejemplo de la figura a continuación, tenemos el punto A en las coordenadas (4,3). Los arrays de la biblioteca Numpy son adecuados para almacenar información de este tipo.

Figura de un punto en un plano bidimensional

Matrices

Al igual que los vectores, las matrices son estructuras de datos que representan múltiples valores relacionados. Una tabla de datos se puede representar mediante una matriz. Aquí tienes un ejemplo de una matriz con 3 filas y 3 columnas:

Figura de una matriz con tres filas y tres columnas

Pero también podemos tener matrices 3D o con más dimensiones. En el ejemplo a continuación, puedes ver una matriz 3D.

Figura de una matriz con tres dimensiones, representada por tres matrices, dispuestas una detrás de la otra y vistas en un ángulo diagonal. Cada matriz es una matriz 3x3 que, juntas, forman la matriz de tres dimensiones.

Las matrices 3D tienen aplicaciones más avanzadas, como el procesamiento de imágenes, el trabajo con animaciones y la modelización matemática.

Un término que escucharás con frecuencia en este curso es "dimensiones". Este término se utilizará aquí para indicar en cuántos ejes varía una información. Por ejemplo, un vector es una secuencia de valores, por lo tanto, podemos decir que varía en solo una dimensión, es unidimensional. En cambio, una matriz 2D, una tabla de datos, tiene filas y columnas, por lo que decimos que es bidimensional.

El término dimensión también puede referirse al número de filas y columnas presentes en una matriz. Podemos tener una matriz con 5 filas y 3 columnas. Eventualmente, puedes ver el número de filas y columnas de una matriz mostrado en su esquina inferior derecha. Siempre escribimos primero el número de filas y luego el número de columnas. Estos números son importantes porque para operaciones como la suma y la multiplicación, las dimensiones de las matrices deben ser compatibles. Solo podemos sumar matrices con el mismo número de filas y columnas. Para que la multiplicación sea posible, el número de columnas de la primera matriz debe ser igual al número de filas de la segunda.
**********************************************************************************
06
Tratamiento de Nan
En esta clase, aprendimos sobre el tratamiento de valores NaN (Not a Number) en un conjunto de datos utilizando NumPy. El objetivo era calcular el precio promedio de las manzanas en Moscú y Kaliningrado.

Primero, se mostró cómo calcular el promedio de precios en Moscú usando np.mean(), obteniendo un resultado de 98 rublos. Sin embargo, al intentar calcular el promedio en Kaliningrado, se encontró un valor NaN, lo que llevó a la necesidad de investigar por qué ocurría esto.

Se utilizó la función np.isnan() para identificar los valores NaN y se explicó cómo contar cuántos había en el array usando np.sum(). Para tratar el valor NaN, se propuso la interpolación, que consiste en tomar los valores adyacentes y calcular su promedio para reemplazar el NaN.

Finalmente, se realizó la interpolación para el valor faltante en Kaliningrado, reemplazándolo con 49.17, y se verificó que ya no había valores NaN. Se concluyó calculando el nuevo promedio de precios en Kaliningrado, que resultó ser 74.55 rublos.

La clase finalizó mencionando que en la próxima sesión se explorarán comparaciones más detalladas entre los precios en diferentes ciudades.

Copiar texto de Luri al portapapeles
///////////////////////////////////////////////////////////////////////////////////////////////
07
Diferencia en un intervalo
 Siguiente pregunta

Patty es una científica que está analizando una base de datos. Está utilizando la biblioteca NumPy para evaluar las columnas de una matriz de datos de un sensor de calor. Cada columna representa la misma información recopilada por un mismo sensor en momentos diferentes. Para validar si el sensor sigue calibrado, necesita que la diferencia entre los valores en las posiciones de una matriz llamada "base" y una columna de la matriz "medidas" sea menor que 0.01.

¿Cómo puede usar NumPy para realizar esta evaluación en la columna cero de la matriz?

Alternativa correta
np.allclose(base, medidas[:, 0], 0.01)

allclose() devolverá True si la diferencia entre los elementos de la matriz es menor que el valor proporcionado de 0.01.

Alternativa correta
np.array_equal(base, medidas[:, 0], 0.01)

Alternativa correta
np.allclose(base, medidas[:, 0], 0.05)

Alternativa correta
np.abs(base - medida[:, 0]) / 0.01
//////////////////////////////////////////////////////////////////////////////////////////
08
Determinando el número de NaNs
 Siguiente pregunta

Estás trabajando con datos de ventas de tu puesto de jugo de limón. Cargaste los datos con load.txt() y, al visualizar la matriz, notaste que había algunos NaNs dentro de ella. Dado que se trata de un archivo grande, decidiste usar código para verificar el número total de estos valores. ¿Cuál es el código adecuado para obtener el resultado deseado en la matriz jugo_de_limon?

Alternativa correta
sum(jugo_de_limon.isnan())

Alternativa correta
np.sum(np.isnan(jugo_de_limon))

También podemos usar np.sum(). Primero usamos isnan para generar una matriz de Verdaderos y Falsos y luego sumamos todos los valores de la matriz.

Alternativa correta
sum(np.isnan(jugo_de_limon))

Primero usamos isnan para generar una matriz de Verdaderos y Falsos y luego sumamos todos los valores de la matriz.

Alternativa correta
sum(np.isnone(jugo_de_limon))

¡Enhorabuena, has acertado!
 Discutir en el Foro
 Siguiente 
***********************************************************************
09
Haga lo que hicimos
 Siguiente pregunta

Ha llegado el momento de poner a prueba los conocimientos adquiridos durante la lección. Continuando con el proyecto de las naranjas/toronjas, ahora debes seleccionar parte de los datos. Las columnas que evaluaremos son el diámetro y el peso. Crea arrays específicos para almacenar el diámetro y el peso de la naranja y la toronja. El diámetro está en la columna cero y el peso en la columna uno. Los datos de las naranjas van hasta la fila 4999 y los datos de las toronjas comienzan en la fila 5000 del archivo.

Después de seleccionar los datos, importa la biblioteca matplotlib y crea un gráfico para el peso en función del diámetro tanto para las naranjas como para las toronjas.

Ver opinión del instructor
Opinión del instructor

Para llevar a cabo esta etapa, puedes seguir los siguientes pasos:

Selección de datos:

diametro_naranja = dato[:5000, 0]
diametro_toronja = dato[5000:, 0]
peso_naranja = dato[:5000, 1]
peso_toronja = dato[5000:, 1]
Copia el código
Visualización:

import matplotlib.pyplot as plt

plt.plot(diametro_naranja, peso_naranja)
plt.plot(diametro_toronja, peso_toronja)
Copia el código
****************************************************************************
10
Lo que aprendimos
 Siguiente pregunta

Lo que aprendimos en esta aula:

Realizar selecciones dentro de arrays.
Construir gráficos utilizando Matplotlib.
Comparar arrays.
Verificar la existencia de NaNs.
********************************************************************
**********************************************************************
03.Operaciones entre arrays
01 Proyecto del aula anterior
¿Comenzando en esta etapa? Aquí puedes descargar los archivos del proyecto que hemos avanzado hasta el aula anterior.

Descargue los archivos en Github
************************************
02
Diferencia entre arrays
¡Claro! En esta clase, aprendimos sobre operaciones entre arrays en NumPy, enfocándonos en cómo analizar y visualizar datos. Utilizamos el ejemplo de los precios de las manzanas en Moscú a lo largo de 87 meses.

Primero, se graficaron los precios y se introdujo la idea de ajustar una línea recta a estos datos, utilizando la ecuación de la recta (Y = A \cdot X + B). Se estimó que el precio de las manzanas aumentaba 1.5 veces por mes, y se creó un nuevo array para representar esta línea recta.

Luego, se comparó la diferencia entre los precios reales y la línea recta, observando que los valores eran en su mayoría negativos. Se ajustó la pendiente a 0.5 para ver si se obtenían mejores resultados, lo que llevó a una mezcla de valores positivos y negativos.

Para calcular la diferencia de manera más precisa, se utilizó la función de potencia de NumPy para elevar al cuadrado las diferencias y luego se sumaron, aplicando la raíz cuadrada para obtener un valor absoluto. Se discutió la importancia de minimizar este valor para un mejor ajuste.

Finalmente, se presentó una forma más elegante de calcular la normalización de la diferencia utilizando el método np.linalg.norm, que permitió obtener el mismo resultado de manera más eficiente.

Esta clase nos mostró cómo trabajar con datos y ajustar modelos de forma manual y también cómo utilizar herramientas de NumPy para simplificar el proceso.
****************************************************
03
Para saber más: copias de arrays
 Siguiente pregunta

Cuando trabajamos con arrays u otras variables en Python, a menudo realizamos copias de las variables con las que estamos tratando. Cuando hacemos una copia de una variable, debemos tener en cuenta lo que sucede con ella para evitar utilizar ciertos valores pensando que son otros valores. Para manejar copias de arrays, la biblioteca Numpy tiene una función específica.

En este ejemplo, tengo un array con el nombre "precio_inmuebles" que quiero copiar.

precio_inmuebles = np.array([10000, 120000, 11000, 200000])
Copia el código
El objetivo es colocar los valores de este array en uno con un nombre específico para los precios de las propiedades en Lima. Vamos a hacer la copia utilizando el signo igual (=).

precio_inmuebles_lima = precio_inmuebles
Copia el código
Si verificas los valores en la nueva variable "precio_inmuebles_lima", verás que son los mismos que los de la variable "precio_inmuebles". Sin embargo, dado que "guardamos" los precios en la variable "precio_inmuebles_lima", ¿qué te parece reemplazar el valor de la primera propiedad en el array "precio_inmuebles" con uno nuevo que acaba de entrar en nuestro registro?

precio_inmuebles[0] = 120000
Copia el código
Si intentas reproducir el proceso realizado hasta ahora, verás que este cambio en el array "precio_inmuebles" también cambió la primera posición del array "precio_inmuebles_lima" al valor de 120000.

Para crear un array independiente del array original, existe una función en Numpy, "np.copy()". Para crear la copia utilizando esta función, simplemente sigue este código:

precio_inmuebles_lima = np.copy(precio_inmuebles)
Copia el código
De esta manera, incluso si modificamos el array "precio_inmuebles", no afectará al array "precio_inmuebles_lima".

Esto sucede porque, cuando usamos el signo igual para copiar el array, tenemos un nuevo array que apunta a las mismas ubicaciones en la memoria. En cambio, cuando usamos "np.copy()", las ubicaciones en la memoria son diferentes.

Imagen con tres tablas de una tabla de dos columnas, ID y VALOR. Desde la primera tabla, hay dos flechas hacia las otras dos tablas: una con el signo igual y la otra con "np.copy()". La figura muestra lo que sucede cuando copiamos un array usando el signo igual y cuando usamos "np.copy()".
****************************************************************
04
Regresión lineal

